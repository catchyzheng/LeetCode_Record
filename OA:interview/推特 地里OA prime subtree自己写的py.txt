
Prime subtrees

# Complete the primeQuery function below.
def primeQuery(n, first, second, values, queries):
    
    def isprime(n):
        if n==1: return False
        if n<=3: return True
        if n % 2 == 0: return False
        i = 2
        while i**2<=n:
            if n%i == 0: return False
            i += 1
        return True
    
    #print n, len(first), len(second), len(values) # n = len(values), len(first) = n - 1
    countdict = [0] * n
    indexdict = [[] for i in range(n)]
    for i in range(len(values)):
        countdict[i] = 1 if isprime(values[i]) else 0
        
    for i in range(len(values)):
        indexdict[i] = []
    for i in range(len(first)):
        idx = second[i] - 1
        ptr = first[i] - 1
        indexdict[idx].append(ptr)
        indexdict[ptr].append(idx)
    
    cnt = 0
    beat = 0
    while cnt < n - 1 or beat == 1000:
        for i in range(1, n):
            if len(indexdict[i]) == 1:
                for x in indexdict[i]:
                    countdict[x] += countdict[i]
                    indexdict[x].remove(i)
                indexdict[i].pop()
                cnt += 1
        beat += 1
    '''
    for i in range(n):
        print i, countdict[i]
            
    
    for i in range(n):
        temp = i
        while indexdict[temp] != temp:
            temp = indexdict[temp]
            countdict[temp] += countdict[i]
    '''
    
    res = [0] * len(queries)
    for i in range(len(queries)):
        res[i] = countdict[queries[i] - 1]
    return res

-----------------------------------


ASCII encoded string 

        print ord('a'), ord('z'), ord('A'), ord('Z'), ord(' ')
        str = '97122121326566899032120'
        print chr(ord('a') + 1)
        
        i = 0
        ans = ''
        
        while i < len(str):
            part = int(str[i:i+2])
            cnt = 2
            #print part
            if part < 65 and part != 32:
                part = int(str[i:i+3])
                cnt = 3
            ans += chr(part)
            print chr(part), i, i + cnt
            i += cnt
        
        print ans

-----------------------------------
Simple text  query

        strs = ['jim likes mary', 'kate likes jim', 'mary dont like kate']
        query = ['mary jim', 'likes']
        for str in strs:
            str = str.split(' ')
        for que in query:
            que = que.split(' ')
        
        ans = []
        for que in query:
            cnt = 0
            for str in strs:
                if all(ele in str for ele in que):
                    cnt += 1
            print cnt

-----------------------------------
who is the closest: Find the cloest same char

        str = 'hackerrank'
        
        query = [4, 1, 6, 8]
        
        dict = {}
        for i in range(len(str)):
            if str[i] not in dict:
                dict[str[i]] = [i]
            else:
                dict[str[i]].append(i)
        
        res = []
        for j in query:
            if str[j] not in dict: res.append( -1)
            index = dict[str[j]].index(j)
            print "index:", index, "j:", j
            if index==0: res.append(dict[str[j]][1])
            elif: index == len(dict[str[j]]) - 1:res.append(dict[str[j]][index - 1])
            else: 

-----------------------------------
Image matching
这个做法仅限于，寻找重合后每个像素值都一样的特例。。

        def dfs(i, j, grid, r, c):
            val = grid[i][j]
            grid[i][j] = 0
            dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]]
            num = 1; sum = val
            for dir in dirs:
                if i+dir[0] < r and i+dir[0]>=0 and j+dir[1]<c and j+dir[1]>=0 and grid[i+dir[0]][j+dir[1]] > 0:
                    (x, y) = dfs(i+dir[0], j+dir[1], grid, r, c)
                    num += x
                    sum += y
            return (num, sum)
        
        grid = [[1,1,1], [1,0,0], [1,0,1]]
        grid2 = [[1,1,1], [1,0,0], [1,0,1]]
        
        
        r = len(grid)
        c = len(grid[0])
        print 'r', r, 'c', c
        for i in range(r):
            for j in range(c):
                grid[i][j] += grid2[i][j]
        
        cnt = 0
        for i in range(r):
            for j in range(c):
                if grid[i][j] > 0: 
                    (num, sum) = dfs(i, j, grid, r, c)
                    
                    if sum % num == 0: 
                        print 'i j', i, j
                        cnt += 1
        
        print "cnt:", cnt


-----------------------------------
no pairs allowed: 修改最少的字符，使得任意两个相邻字符都不相同
	s = 'abbbaaab'
        cnt = 1
        ans = 0
        for i in range(1, len(s)):
            if s[i] != s[i-1]:
                if cnt > 1: 
                    ans += cnt/2
                cnt = 1
            if s[i] == s[i-1]:
                cnt += 1
        print ans

-----------------------------------

