[92. Backpack](https://www.lintcode.com/problem/backpack/description)<br>
[125. Backpack II](https://www.lintcode.com/problem/backpack-ii/description)<br>
第一题的物品没有价值，直接把费用当做价值考虑就行。。<br>
几个要注意的点：<br>
1 这是01背包，故dp数组的v要从<背包容量值>往0遍历。<br>
2 因为待选物品的的价值和费用并不按照顺序排列，因此需要从m遍历到0才行。
```
public int backPack(int m, int[] A, int[] V) {
    int len = A.length;
    int [] dp = new int[m+1];
    for(int i=0; i<len; ++i){
        for(int v=m; v>=0; --v){
            if(v>=A[i]) dp[v] = Math.max(dp[v], dp[v-A[i]] + V[i]);
        }
    }
    return dp[m];
}
```
01背包，v逆序遍历。完全背包，v顺序遍历。多重背包，转化为C*2^k,V*2^k，O(lgn)。希望日后你还能看懂现在的笔记。。。。

如果不要求完全放满背包，那么可以初始化dp都为0。否则，如果要求完全放满，那么只能初始化dp[0]=0,其余为dp[i]=负无穷。

一个简单有效的优化
完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j 满足Ci <= Cj且Wi >= Wj，则将可以将物品j 直接去掉，不用考虑。
这个优化的正确性是显然的：任何情况下都可将价值小费用高的j 换成物美价廉的i，得到的方案至少不会更差。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。
这个优化可以简单的O(N2) 地实现，一般都可以承受。另外，针对背包问题而言，比较不错的一种方法是：首先将费用大于V 的物品去掉，然后使用类似计数排序的做法，计算出费用相同的物品中价值最高的是哪个，可以O(V + N) 地完成这个优化。这个不太重要的过程就不给出伪代码了，希望你能独立思考写出伪代码或程序。
